package main

/*
Pat Alwell
Software Engineer - Cloud

Test Functions for concurrentHandlers REST API.

*/

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

func TestPing(t *testing.T) {

	// Initialize a new httptest.ResponseRecorder
	rr := httptest.NewRecorder()

	// Initialize a new dummy http.Request
	r, err := http.NewRequest(http.MethodGet, "/", nil)
	if err != nil {
		t.Fatal(err)
	}
	// Call the ping handler function, passing in the
	// httptest.ResponseRecorder and http.Request.
	Ping(rr, r)
	// Call the Result() method on the http.ResponseRecorder to get the
	// http.Response generated by the ping handler.
	rs := rr.Result()

	// We can then examine the http.Response to check that the status code
	// written by the ping handler was 200.

	if rs.StatusCode != http.StatusOK {
		t.Errorf("want %d; got %d", http.StatusOK, rs.StatusCode)

	}
	// And we can check that the response body written by the ping handler
	// equals "OK".
	defer rs.Body.Close()

	body, err := ioutil.ReadAll(rs.Body)
	if err != nil {
		t.Fatal(err)
	}
	if string(body) != "OK" {
		t.Errorf("want body to equal %q", "OK")
	}

}

func TestGetStockData(t *testing.T) {

	//create a flag channel for our function
	done := make(chan interface{})
	defer close(done)

	tickers := []string{"MSFT"}

	//pass tickers to get stock data with multiple routines
	for result := range GetStockData(done, tickers...) {
		if result.Error != nil {
			t.Error(result.Error)
			continue
		}
		if result.Response.Symbol != "MSFT" {
			t.Errorf("Expecting MSFT but instead got %s", result.Response.Symbol)
		}
	}
}

func TestCreateUsers(t *testing.T) {

	// Initialize a new httptest.ResponseRecorder
	rr := httptest.NewRecorder()

	//Create a dummy user
	testUser :=
		User{
			Id:        1,
			Email:     "test@gmail.com",
			FirstName: "Test",
			LastName:  "User",
			Stocks:    []string{"MSFT"},
		}

	js, err := json.Marshal(testUser)
	if err != nil {
		t.Fatal(err)
	}

	// Initialize a new dummy http.Request
	r, err := http.NewRequest(http.MethodPost, "/user/create", bytes.NewBuffer(js))
	r.Header.Set("Content-Type", "application/json")
	if err != nil {
		t.Fatal(err)
	}
	// Call the createUser handler function, passing in the
	// httptest.ResponseRecorder and http.Request.
	CreateUser(rr, r)

	// Call the Result() method on the http.ResponseRecorder to get the
	// http.Response generated by the createUser handler.
	rs := rr.Result()

	// We can then examine the http.Response to check that the status code
	// written by the createUser handler was 200.

	if rs.StatusCode != http.StatusOK {
		t.Errorf("want %d; got %d", http.StatusOK, rs.StatusCode)

	}

}

func TestShowAllUsers(t *testing.T) {

	// Initialize a new httptest.ResponseRecorder
	rr := httptest.NewRecorder()

	testUser :=
		User{
			Id:        1,
			Email:     "test@gmail.com",
			FirstName: "Test",
			LastName:  "User",
			Stocks:    []string{"MSFT"},
		}

	done := make(chan interface{})

	//iterate over our result channel for stock data
	for result := range GetStockData(done, testUser.Stocks...) {
		if result.Error != nil {
			log.Println(result.Error.Error())
			continue
		}

		//update our portfolio
		testUser.Portfolio = append(testUser.Portfolio, result.Response)

		//create user list
		var userList []User
		userList = append(userList, testUser)

		js, err := json.Marshal(userList)
		if err != nil {
			t.Fatal(err)
		}

		// Initialize a new dummy http.Request
		r, err := http.NewRequest(http.MethodGet, "/user/all", nil)
		if err != nil {
			t.Fatal(err)
		}
		// Call the showAllUsers handler function, passing in the
		// httptest.ResponseRecorder and http.Request.
		ShowAllUsers(rr, r)

		// Call the Result() method on the http.ResponseRecorder to get the
		// http.Response generated by the showAllUsers handler.
		rs := rr.Result()

		// We can then examine the http.Response to check that the status code
		// written by the showAllUsers handler was 200.

		if rs.StatusCode != http.StatusOK {
			t.Errorf("want %d; got %d", http.StatusOK, rs.StatusCode)

		}
		// And we can check that the response body written by the showAllUsers handler
		// by making a comparison between []byte's
		defer rs.Body.Close()

		body, err := ioutil.ReadAll(rs.Body)
		if err != nil {
			t.Fatal(err)
		}

		fmt.Printf("%s", body)

		if strings.Compare(string(body), string(js)) != 1 {
			t.Errorf("want body to equal %s", js)
		}
	}
}

func TestShowUser(t *testing.T) {
	// Initialize a new httptest.ResponseRecorder
	rr := httptest.NewRecorder()

	testUser :=
		User{
			Id:        1,
			Email:     "test@gmail.com",
			FirstName: "Test",
			LastName:  "User",
			Stocks:    []string{"MSFT"},
		}

	done := make(chan interface{})

	//iterate over our result channel for stock data
	for result := range GetStockData(done, testUser.Stocks...) {
		if result.Error != nil {
			log.Println(result.Error.Error())
			continue
		}

		//update our portfolio
		testUser.Portfolio = append(testUser.Portfolio, result.Response)

		//create user list
		var userList []User
		userList = append(userList, testUser)

		js, err := json.Marshal(userList)
		if err != nil {
			t.Fatal(err)
		}

		// Initialize a new dummy http.Request
		r, err := http.NewRequest(http.MethodGet, "/user?id=1", nil)
		if err != nil {
			t.Fatal(err)
		}
		// Call the showUser handler function, passing in the
		// httptest.ResponseRecorder and http.Request.
		ShowUser(rr, r)

		// Call the Result() method on the http.ResponseRecorder to get the
		// http.Response generated by the showUser handler.
		rs := rr.Result()

		// We can then examine the http.Response to check that the status code
		// written by the showUser handler was 200.

		if rs.StatusCode != http.StatusOK {
			t.Errorf("want %d; got %d", http.StatusOK, rs.StatusCode)

		}
		// And we can check that the response body written by the showUser handler
		// by making a comparison between []byte's
		defer rs.Body.Close()

		body, err := ioutil.ReadAll(rs.Body)
		if err != nil {
			t.Fatal(err)
		}

		if strings.Compare(string(body), string(js)) != 1 {
			t.Errorf("want body to equal %s", js)
		}
	}
}

func TestEditUser(t *testing.T) {
	// Initialize a new httptest.ResponseRecorder
	rr := httptest.NewRecorder()

	testUser := User{
		Id:        1,
		Email:     "test@gmail.com",
		FirstName: "Edit",
		LastName:  "User",
		Stocks:    []string{"AAPL"},
	}

	var userList []User

	done := make(chan interface{})

	//iterate over our result channel for stock data
	for result := range GetStockData(done, testUser.Stocks...) {
		if result.Error != nil {
			log.Println(result.Error.Error())
			continue
		}

		//update our portfolio
		testUser.Portfolio = append(testUser.Portfolio, result.Response)
	}

	userList = append(userList, testUser)

	//create our json objects for interacting with method
	js, err := json.Marshal(testUser)
	if err != nil {
		t.Fatal(err)
	}

	jsArray, err := json.Marshal(userList)
	if err != nil {
		t.Fatal(err)
	}

	// Initialize a new dummy http.Request with our testUser json
	r, err := http.NewRequest(http.MethodPut, "/user/edit?id=1", bytes.NewBuffer(js))
	r.Header.Set("Content-Type", "application/json")
	if err != nil {
		t.Fatal(err)
	}
	// Call the editUser handler function, passing in the
	// httptest.ResponseRecorder and http.Request.
	EditUser(rr, r)

	// Call the Result() method on the http.ResponseRecorder to get the
	// http.Response generated by the editUser handler.
	rs := rr.Result()

	// We can then examine the http.Response to check that the status code
	// written by the editUser handler was 200.

	if rs.StatusCode != http.StatusOK {
		t.Errorf("want %d; got %d", http.StatusOK, rs.StatusCode)

	}

	// And we can check that the response body written by the editUser handler
	// by making a comparison between []byte's
	defer rs.Body.Close()

	body, err := ioutil.ReadAll(rs.Body)
	if err != nil {
		t.Fatal(err)
	}

	if strings.Compare(string(body), string(jsArray)) != 1 {
		t.Errorf("want body to equal %s", jsArray)
	}
}

func TestDeleteUser(t *testing.T) {
	// Initialize a new httptest.ResponseRecorder
	rr := httptest.NewRecorder()

	testUser :=
		User{
			Id:        1,
			Email:     "test@gmail.com",
			FirstName: "Test",
			LastName:  "User",
			Stocks:    []string{"MSFT"},
		}

	done := make(chan interface{})

	//iterate over our result channel for stock data
	for result := range GetStockData(done, testUser.Stocks...) {
		if result.Error != nil {
			log.Println(result.Error.Error())
			continue
		}

		//update our portfolio
		testUser.Portfolio = append(testUser.Portfolio, result.Response)

		js, err := json.Marshal(testUser)
		if err != nil {
			t.Fatal(err)
		}

		// Initialize a new dummy http.Request
		r, err := http.NewRequest(http.MethodDelete, "/user/delete?id=1", nil)
		if err != nil {
			t.Fatal(err)
		}
		// Call the deleteUser handler function, passing in the
		// httptest.ResponseRecorder and http.Request.

		DeleteUser(rr, r)
		// Call the Result() method on the http.ResponseRecorder to get the
		// http.Response generated by the deleteUser handler.
		rs := rr.Result()

		// We can then examine the http.Response to check that the status code
		// written by the deleteUser handler was 200.

		if rs.StatusCode != http.StatusOK {
			t.Errorf("want %d; got %d", http.StatusOK, rs.StatusCode)

		}
		// And we can check that the response body written by the deleteUSer handler
		// by making a comparison between []byte's
		defer rs.Body.Close()

		body, err := ioutil.ReadAll(rs.Body)
		if err != nil {
			t.Fatal(err)
		}

		testResponse := fmt.Sprintf("Deleted %s", js)

		if strings.Compare(string(body), string(testResponse)) != -1 {
			t.Errorf("want body to equal %s", testResponse)
		}
	}
}
